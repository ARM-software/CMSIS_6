<!-- HTML header for doxygen 1.9.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CMSIS-RTOS2: Theory of Operation</title>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="extra_navtree.css" rel="stylesheet" type="text/css"/>
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="extra_search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="printComponentTabs.js"></script>
<script type="text/javascript" src="footer.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<script type="text/javascript" src="darkmode_toggle.js"></script>
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="extra_navtree.css" rel="stylesheet" type="text/css"/>
<link href="extra_search.css" rel="stylesheet" type="text/css"/>
<link href="version.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="../../version.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 55px;">
  <td id="projectlogo" style="padding: 1.5em;"><img alt="Logo" src="cmsis_logo_white_small.png"/></td>
  <td style="padding-left: 1em; padding-bottom: 1em;padding-top: 1em;">
   <div id="projectname">CMSIS-RTOS2
   &#160;<span id="projectnumber"><script type="text/javascript">
     <!--
     writeHeader.call(this);
     writeVersionDropdown.call(this, "CMSIS-RTOS2");
     //-->
    </script>
   </span>
   </div>
   <div id="projectbrief">Real-Time Operating System: API and RTX Reference Implementation</div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
  <!--END !PROJECT_NAME-->
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<div id="CMSISnav" class="tabs1">
  <ul class="tablist">
    <script type="text/javascript">
      writeComponentTabs.call(this);
    </script>
  </ul>
</div>
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('theory_of_operation.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Theory of Operation </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#SystemStartup">System Startup</a></li>
<li class="level1"><a href="#Scheduler">Scheduler</a></li>
<li class="level1"><a href="#MemoryAllocation">Memory Allocation</a><ul><li class="level2"><a href="#GlobalMemoryPool">Global Memory Pool</a></li>
<li class="level2"><a href="#ObjectMemoryPool">Object-specific Memory Pools</a></li>
<li class="level2"><a href="#StaticObjectMemory">Static Object Memory</a></li>
</ul>
</li>
<li class="level1"><a href="#ThreadStack">Thread Stack Management</a></li>
<li class="level1"><a href="#lowPower">Low-Power Operation</a></li>
<li class="level1"><a href="#kernelTimer">RTX Kernel Timer Tick</a><ul><li class="level2"><a href="#TickLess">Tick-less Low-Power Operation</a></li>
</ul>
</li>
<li class="level1"><a href="#rtx_os_h">RTX5 Header File</a></li>
<li class="level1"><a href="#CMSIS_RTOS_TimeOutValue">Timeout Value</a></li>
<li class="level1"><a href="#CMSIS_RTOS_ISR_Calls">Calls from Interrupt Service Routines</a></li>
<li class="level1"><a href="#CMSIS_RTOS_svcFunctions">SVC Functions</a></li>
<li class="level1"><a href="#cre_rtx_proj_clib_arm">Arm C library multi-threading protection</a></li>
</ul>
</div>
<div class="textblock"><p>Many aspects of the kernel are configurable and the configuration options are mentioned where applicable.</p>
<h1><a class="anchor" id="SystemStartup"></a>
System Startup</h1>
<p>Since main is no longer a thread RTX5 does not interfere with the system startup until main is reached. Once the execution reaches <code>main()</code> there is a recommended order to initialize the hardware and start the kernel. This is also reflected in the user code template file "CMSIS-RTOS2 'main' function" supplied with the RTX5 component.</p>
<p>Your application's <code>main()</code> should implement at least the following in the given order:</p><ol type="1">
<li>Initialization and configuration of hardware including peripherals, memory, pins, clocks and the interrupt system.</li>
<li>Update the system core clock using the respective <a href="../../Core/html/group__system__init__gr.html">CMSIS-Core (Cortex-M)</a>  or <a href="../../Core_A/html/group__system__init__gr.html">CMSIS-Core (Cortex-A)</a>  function.</li>
<li>Initialize the CMSIS-RTOS kernel using <a class="el" href="group__CMSIS__RTOS__KernelCtrl.html#gae818f6611d25ba3140bede410a52d659">osKernelInitialize</a>.</li>
<li>Optionally, create one thread (for example <code>app_main</code>), which is used as a main thread using <a class="el" href="group__CMSIS__RTOS__ThreadMgmt.html#ga48d68b8666d99d28fa646ee1d2182b8f">osThreadNew</a>. This thread should take care of creating and starting objects, once it is run by the scheduler. Alternatively, threads can be created in <code>main()</code> directly.</li>
<li>Start the RTOS scheduler using <a class="el" href="group__CMSIS__RTOS__KernelCtrl.html#ga9ae2cc00f0d89d7b6a307bba942b5221">osKernelStart</a> which also configures the system tick timer and initializes RTOS specific interrupts. This function does not return in case of successful execution. Therefore, any application code after <b>osKernelStart</b> will not be executed.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>Modifying priorities and groupings in the NVIC by the application after the above sequence is not recommended.</li>
<li>Before executing <a class="el" href="group__CMSIS__RTOS__KernelCtrl.html#ga9ae2cc00f0d89d7b6a307bba942b5221">osKernelStart</a>, only the functions <a class="el" href="group__CMSIS__RTOS__KernelCtrl.html#ga6f7764e7250c5c5364c00c45a5d1d199">osKernelGetInfo</a>, <a class="el" href="group__CMSIS__RTOS__KernelCtrl.html#ga48b69b81012fce051f639be288b243ba">osKernelGetState</a>, and object creation functions (osXxxNew) may be called.</li>
</ul>
</dd></dl>
<h1><a class="anchor" id="Scheduler"></a>
Scheduler</h1>
<p>RTX5 implements a low-latency preemptive scheduler. Major parts of RTX5 are executed in handler mode such as</p><ul>
<li>SysTick_Handler used for time-based scheduling.</li>
<li>SVC_Handler used for lock-based scheduling.</li>
<li>PendSV_Handler used for interrupt-based scheduling.</li>
</ul>
<p>In order to be low-latency with respect to ISR execution those system exceptions are configured to use the lowest priority groups available. The priorities are configured such that no preemption happens between them. Thus no interrupt critical sections (i.e. interrupt locks) are needed to protect the scheduler.</p>
<div class="image">
<img src="scheduling.png" alt=""/>
<div class="caption">
Thread scheduling and interrupt execution</div></div>
<p>The scheduler combines priority and round-robin based context switches. The example depicted in the image above contains four threads (1, 2, 3, and 4). Threads 1 and 2 share the same priority, thread 3 has a higher one and thread 4 the highest (<a class="el" href="group__CMSIS__RTOS__ThreadMgmt.html#a6a5183df4c54c3e28dc8dc704f2487d5">osThreadAttr_t::priority</a>). As long as threads 3 and 4 are blocked the scheduler switches between thread 1 and 2 on a time-slice basis (round-robin). The time-slice for round-robin scheduling can be configured, see Round-Robin Timeout in <a class="el" href="config_rtx5.html#systemConfig">System Configuration</a>.</p>
<p>Thread 2 unblocks thread 3 by an arbitrary RTOS-call (executed in <a class="el" href="theory_of_operation.html#CMSIS_RTOS_svcFunctions">SVC</a> handler mode) at time index 2. The scheduler switches to thread 3 immediately because thread 3 has the highest priority. Thread 4 is still blocked.</p>
<p>At time index 4 an interrupt (ISR) occurs and preempts the SysTick_Handler. RTX does not add any latency to the interrupt service execution. The ISR routine uses an RTOS-call that unblocks thread 4. Instead of switching to thread 4 immediately the PendSV flag is set to defer the context switching. The PendSV_Handler is executed right after the SysTick_Handler returns and the deferred context switch to thread 4 is carried out. As soon as highest priority thread 4 blocks again by using a blocking RTOS-call execution is switched back to thread 3 immediately during time index 5.</p>
<p>At time index 5 thread 3 uses a blocking RTOS-call as well. Thus the scheduler switches back to thread 2 for time index 6. At time index 7 the scheduler uses the round-robin mechanism to switch to thread 1 and so on.</p>
<h1><a class="anchor" id="MemoryAllocation"></a>
Memory Allocation</h1>
<p>RTX5 objects (thread, mutex, semaphore, timer, message queue, thread and event flags, as well as memory pool) require dedicated RAM memory. Objects can be created using os<em>Object</em>New() calls and deleted using os<em>Object</em>Delete() calls. The related object memory needs to be available during the lifetime of the object.</p>
<p>RTX5 offers three different memory allocation methods for objects:</p><ul>
<li><a class="el" href="theory_of_operation.html#GlobalMemoryPool">Global Memory Pool</a> uses a single global memory pool for all objects. It is easy to configure, but may have the disadvantage for memory fragmentation when objects with different sizes are created and destroyed.</li>
<li><a class="el" href="theory_of_operation.html#ObjectMemoryPool">Object-specific Memory Pools</a> uses a fixed-size memory pool for each object type. The method is time deterministic and avoids memory fragmentation.</li>
<li><a class="el" href="theory_of_operation.html#StaticObjectMemory">Static Object Memory</a> reserves memory during compile time and completely avoids that a system can be out of memory. This is typically a required for some safety critical systems.</li>
</ul>
<p>It possible to intermix all the memory allocation methods in the same application.</p>
<h2><a class="anchor" id="GlobalMemoryPool"></a>
Global Memory Pool</h2>
<p>The global memory pool allocates all objects from a memory area. This method of memory allocation is the default configuration setting of RTX5.</p>
<div class="image">
<img src="MemAllocGlob.png" alt=""/>
<div class="caption">
Global Memory Pool for all objects</div></div>
<p>When the memory pool does not provide sufficient memory, the creation of the object fails and the related os<em>Object</em>New() function returns <span class="XML-Token">NULL</span>.</p>
<p>Enabled in <a class="el" href="config_rtx5.html#systemConfig">System Configuration</a>.</p>
<h2><a class="anchor" id="ObjectMemoryPool"></a>
Object-specific Memory Pools</h2>
<p>Object-specific memory pools avoids memory fragmentation with a dedicated fixed-size memory management for each object type. This type of memory pools are fully time deterministic, which means that object creation and destruction takes always the same fixed amount of time. As a fixed-size memory pool is specific to an object type, the handling of out-of-memory situations is simplified.</p>
<div class="image">
<img src="MemAllocSpec.png" alt=""/>
<div class="caption">
One memory pool per object type</div></div>
<p>Object-specific memory pools are selectively enabled for each object type, e.g: mutex or thread using the RTX configuration file:</p><ul>
<li>Enabled in <a class="el" href="config_rtx5.html#threadConfig">Thread Configuration</a> for thread objects.</li>
<li>Enabled in <a class="el" href="config_rtx5.html#timerConfig">Timer Configuration</a> for timer objects.</li>
<li>Enabled in <a class="el" href="config_rtx5.html#eventFlagsConfig">Event Flags Configuration</a> for event objects.</li>
<li>Enabled in <a class="el" href="config_rtx5.html#mutexConfig">Mutex Configuration</a> for mutex objects.</li>
<li>Enabled in <a class="el" href="config_rtx5.html#semaphoreConfig">Semaphore Configuration</a> for semaphore.</li>
<li>Enabled in <a class="el" href="config_rtx5.html#memPoolConfig">Memory Pool Configuration</a> for memory pools.</li>
<li>Enabled in <a class="el" href="config_rtx5.html#msgQueueConfig">Message Queue Configuration</a> for message objects.</li>
</ul>
<p>When the memory pool does not provide sufficient memory, the creation of the object fails and the related os<em>Object</em>New() function returns <span class="XML-Token">NULL</span>.</p>
<h2><a class="anchor" id="StaticObjectMemory"></a>
Static Object Memory</h2>
<p>In contrast to the dynamic memory allocations, the static memory allocation requires compile-time allocation of object memory.</p>
<div class="image">
<img src="MemAllocStat.png" alt=""/>
<div class="caption">
Statically allocated memory for all objects</div></div>
<p>Static memory allocation can be achieved by providing user-defined memory using attributes at object creation, see <a class="el" href="group__CMSIS__RTOS__MemoryMgmt.html#CMSIS_RTOS_MemoryMgmt_Manual">Manual User-defined Allocation</a>. Please take special note of the following restrictions:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Memory type   </th><th class="markdownTableHeadNone">Requirements    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Control Block (osXxxAttr_t::cb_mem)   </td><td class="markdownTableBodyNone">4-Byte alignment. Size defined by osRtxThreadCbSize, osRtxTimerCbSize, osRtxEventFlagsCbSize, osRtxMutexCbSize, osRtxSemaphoreCbSize, osRtxMemoryPoolCbSize, osRtxMessageQueueCbSize.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Thread Stack (<a class="el" href="group__CMSIS__RTOS__ThreadMgmt.html#ad7c9b42355a4c8b9467130ab3fb19e43" title="memory for stack">osThreadAttr_t::stack_mem</a>)   </td><td class="markdownTableBodyNone">8-Byte alignment. Size is application specific, i.e. amount of stack variables and frames.    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Memory Pool (<a class="el" href="group__CMSIS__RTOS__PoolMgmt.html#a5799465cca9c71c5587ceb0986f5b06a" title="memory for data storage">osMemoryPoolAttr_t::mp_mem</a>)   </td><td class="markdownTableBodyNone">4-Byte alignment. Size calculated with osRtxMemoryPoolMemSize.    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Message Queue (<a class="el" href="group__CMSIS__RTOS__Message.html#a4e208dc0fb049b42c4b90cbd2791c5ad" title="memory for data storage">osMessageQueueAttr_t::mq_mem</a>)   </td><td class="markdownTableBodyNone">4-Byte alignment. Size calculated with osRtxMessageQueueMemSize.   </td></tr>
</table>
<p>In order to allow RTX5 aware debugging, i.e. Component Viewer, to recognize control blocks these needs to be placed in individual memory sections, i.e. using <code>__attribute__((section(...)))</code>.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">RTX Object   </th><th class="markdownTableHeadNone">Linker Section    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Thread   </td><td class="markdownTableBodyNone"><code>.bss.os.thread.cb</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Timer   </td><td class="markdownTableBodyNone"><code>.bss.os.timer.cb</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Event Flags   </td><td class="markdownTableBodyNone"><code>.bss.os.evflags.cb</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Mutex   </td><td class="markdownTableBodyNone"><code>.bss.os.mutex.cb</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Semaphore   </td><td class="markdownTableBodyNone"><code>.bss.os.semaphore.cb</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">Memory Pool   </td><td class="markdownTableBodyNone"><code>.bss.os.mempool.cb</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Message Queue   </td><td class="markdownTableBodyNone"><code>.bss.os.msgqueue.cb</code>   </td></tr>
</table>
<p>It must be assured that these sections are placed into contiguous memory. This can fail, i.e. sections end up being split over multiple memory segments, when assigning compilation units to memory segments, manually.</p>
<p>The following code example shows how to create an OS object using static memory.</p>
<p><b> Code Example:</b> </p><div class="fragment"><div class="line"><span class="comment">/*----------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"> * CMSIS-RTOS &#39;main&#39; function template</span></div>
<div class="line"><span class="comment"> *---------------------------------------------------------------------------*/</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;RTE_Components.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include  CMSIS_device_header</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="cmsis__os2_8h.html">cmsis_os2.h</a>&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">//include rtx_os.h for types of RTX objects</span></div>
<div class="line"><span class="preprocessor">#include &quot;rtx_os.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">//The thread function instanced in this example</span></div>
<div class="line"><span class="keywordtype">void</span> worker(<span class="keywordtype">void</span> *arg)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">while</span>(1) </div>
<div class="line">  {</div>
<div class="line">    <span class="comment">//work</span></div>
<div class="line">    <a class="code hl_function" href="group__CMSIS__RTOS__Wait.html#gaf6055a51390ef65b6b6edc28bf47322e">osDelay</a>(10000);</div>
<div class="line">  }  </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define objects that are statically allocated for worker thread 1</span></div>
<div class="line">__attribute__((section(<span class="stringliteral">&quot;.bss.os.thread.cb&quot;</span>)))</div>
<div class="line">osRtxThread_t worker_thread_tcb_1;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Reserve two areas for the stacks of worker thread 1</span></div>
<div class="line"><span class="comment">// uint64_t makes sure the memory alignment is 8</span></div>
<div class="line">uint64_t worker_thread_stk_1[64];</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define the attributes which are used for thread creation</span></div>
<div class="line"><span class="comment">// Optional const saves RAM memory and includes the values in periodic ROM tests </span></div>
<div class="line">const <a class="code hl_struct" href="group__CMSIS__RTOS__ThreadMgmt.html#structosThreadAttr__t">osThreadAttr_t</a> worker_attr_1 = {</div>
<div class="line">  <span class="stringliteral">&quot;wrk1&quot;</span>,</div>
<div class="line">  <a class="code hl_define" href="group__CMSIS__RTOS__ThreadMgmt.html#ga249499c519f3f8eef5673009ab6cfcbe">osThreadJoinable</a>,</div>
<div class="line">  &amp;worker_thread_tcb_1,</div>
<div class="line">  <span class="keyword">sizeof</span>(worker_thread_tcb_1),</div>
<div class="line">  &amp;worker_thread_stk_1[0],</div>
<div class="line">  <span class="keyword">sizeof</span>(worker_thread_stk_1),</div>
<div class="line">  <a class="code hl_enumvalue" href="cmsis__os2_8h.html#gad4e3e0971b41f2d17584a8c6837342eca17b36cd9cd38652c2bc6d4803990674b">osPriorityAboveNormal</a>,</div>
<div class="line">  0</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define ID object for thread</span></div>
<div class="line"><a class="code hl_typedef" href="group__CMSIS__RTOS__ThreadMgmt.html#gaa6c32fe2a3e0a2e01f212d55b02e51c7">osThreadId_t</a> th1;</div>
<div class="line"> </div>
<div class="line"><span class="comment">/*----------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"> * Application main thread</span></div>
<div class="line"><span class="comment"> *---------------------------------------------------------------------------*/</span></div>
<div class="line"><span class="keywordtype">void</span> app_main (<span class="keywordtype">void</span> *argument) {</div>
<div class="line">  uint32_t param = NULL;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create an instance of the worker thread with static resources (TCB and stack)</span></div>
<div class="line">  th1 = <a class="code hl_function" href="group__CMSIS__RTOS__ThreadMgmt.html#ga48d68b8666d99d28fa646ee1d2182b8f">osThreadNew</a>(worker, &amp;param, &amp;worker_attr_1);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (;;) {}</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main (<span class="keywordtype">void</span>) {</div>
<div class="line">  <span class="comment">// System Initialization</span></div>
<div class="line">  SystemCoreClockUpdate();</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">  <a class="code hl_function" href="group__CMSIS__RTOS__KernelCtrl.html#gae818f6611d25ba3140bede410a52d659">osKernelInitialize</a>();                 <span class="comment">// Initialize CMSIS-RTOS</span></div>
<div class="line">  <a class="code hl_function" href="group__CMSIS__RTOS__ThreadMgmt.html#ga48d68b8666d99d28fa646ee1d2182b8f">osThreadNew</a>(app_main, NULL, NULL);    <span class="comment">// Create application main thread</span></div>
<div class="line">  <a class="code hl_function" href="group__CMSIS__RTOS__KernelCtrl.html#ga9ae2cc00f0d89d7b6a307bba942b5221">osKernelStart</a>();                      <span class="comment">// Start thread execution</span></div>
<div class="line">  <span class="keywordflow">for</span> (;;) {}</div>
<div class="line">}</div>
<div class="ttc" id="acmsis__os2_8h_html"><div class="ttname"><a href="cmsis__os2_8h.html">cmsis_os2.h</a></div></div>
<div class="ttc" id="acmsis__os2_8h_html_gad4e3e0971b41f2d17584a8c6837342eca17b36cd9cd38652c2bc6d4803990674b"><div class="ttname"><a href="cmsis__os2_8h.html#gad4e3e0971b41f2d17584a8c6837342eca17b36cd9cd38652c2bc6d4803990674b">osPriorityAboveNormal</a></div><div class="ttdeci">@ osPriorityAboveNormal</div><div class="ttdoc">Priority: above normal.</div><div class="ttdef"><b>Definition:</b> cmsis_os2.h:147</div></div>
<div class="ttc" id="agroup__CMSIS__RTOS__KernelCtrl_html_ga9ae2cc00f0d89d7b6a307bba942b5221"><div class="ttname"><a href="group__CMSIS__RTOS__KernelCtrl.html#ga9ae2cc00f0d89d7b6a307bba942b5221">osKernelStart</a></div><div class="ttdeci">osStatus_t osKernelStart(void)</div><div class="ttdoc">Start the RTOS Kernel scheduler.</div></div>
<div class="ttc" id="agroup__CMSIS__RTOS__KernelCtrl_html_gae818f6611d25ba3140bede410a52d659"><div class="ttname"><a href="group__CMSIS__RTOS__KernelCtrl.html#gae818f6611d25ba3140bede410a52d659">osKernelInitialize</a></div><div class="ttdeci">osStatus_t osKernelInitialize(void)</div><div class="ttdoc">Initialize the RTOS Kernel.</div></div>
<div class="ttc" id="agroup__CMSIS__RTOS__ThreadMgmt_html_ga249499c519f3f8eef5673009ab6cfcbe"><div class="ttname"><a href="group__CMSIS__RTOS__ThreadMgmt.html#ga249499c519f3f8eef5673009ab6cfcbe">osThreadJoinable</a></div><div class="ttdeci">#define osThreadJoinable</div><div class="ttdoc">Thread created in joinable mode.</div><div class="ttdef"><b>Definition:</b> cmsis_os2.h:207</div></div>
<div class="ttc" id="agroup__CMSIS__RTOS__ThreadMgmt_html_ga48d68b8666d99d28fa646ee1d2182b8f"><div class="ttname"><a href="group__CMSIS__RTOS__ThreadMgmt.html#ga48d68b8666d99d28fa646ee1d2182b8f">osThreadNew</a></div><div class="ttdeci">osThreadId_t osThreadNew(osThreadFunc_t func, void *argument, const osThreadAttr_t *attr)</div><div class="ttdoc">Create a thread and add it to Active Threads.</div></div>
<div class="ttc" id="agroup__CMSIS__RTOS__ThreadMgmt_html_gaa6c32fe2a3e0a2e01f212d55b02e51c7"><div class="ttname"><a href="group__CMSIS__RTOS__ThreadMgmt.html#gaa6c32fe2a3e0a2e01f212d55b02e51c7">osThreadId_t</a></div><div class="ttdeci">void * osThreadId_t</div><div class="ttdef"><b>Definition:</b> cmsis_os2.h:253</div></div>
<div class="ttc" id="agroup__CMSIS__RTOS__ThreadMgmt_html_structosThreadAttr__t"><div class="ttname"><a href="group__CMSIS__RTOS__ThreadMgmt.html#structosThreadAttr__t">osThreadAttr_t</a></div><div class="ttdoc">Attributes structure for thread.</div><div class="ttdef"><b>Definition:</b> cmsis_os2.h:282</div></div>
<div class="ttc" id="agroup__CMSIS__RTOS__Wait_html_gaf6055a51390ef65b6b6edc28bf47322e"><div class="ttname"><a href="group__CMSIS__RTOS__Wait.html#gaf6055a51390ef65b6b6edc28bf47322e">osDelay</a></div><div class="ttdeci">osStatus_t osDelay(uint32_t ticks)</div><div class="ttdoc">Wait for Timeout (Time Delay).</div></div>
</div><!-- fragment --><h1><a class="anchor" id="ThreadStack"></a>
Thread Stack Management</h1>
<p>For Cortex-M processors without floating point unit the thread context requires 64 bytes on the local stack.</p>
<dl class="section note"><dt>Note</dt><dd>For Cortex-M4/M7 with FP the thread context requires 200 bytes on the local stack. For these devices the default stack space should be increased to a minimum of 300 bytes.</dd></dl>
<p>Each thread is provided with a separate stack that holds the thread context and stack space for automatic variables and return addresses for function call nesting. The stack sizes of RTX threads are flexibly configurable as explained in the section <a class="el" href="config_rtx5.html#threadConfig">Thread Configuration</a>. RTX offers a configurable checking for stack overflows and stack utilization.</p>
<h1><a class="anchor" id="lowPower"></a>
Low-Power Operation</h1>
<p>The system thread <b>osRtxIdleThread</b> can be use to switch the system into a low-power mode. The easiest form to enter a low-power mode is the execution of the <code>__WFE</code> function that puts the processor into a sleep mode where it waits for an event.</p>
<p><b>Code Example:</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;RTE_Components.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include CMSIS_device_header            </span><span class="comment">/* Device definitions                 */</span><span class="preprocessor"></span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> osRtxIdleThread (<span class="keywordtype">void</span>) {</div>
<div class="line">  <span class="comment">/* The idle demon is a system thread, running when no other thread is       */</span></div>
<div class="line">  <span class="comment">/* ready to run.                                                            */</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">for</span> (;;) {</div>
<div class="line">    __WFE();                            <span class="comment">/* Enter sleep mode                   */</span></div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><code>__WFE()</code> is not available in every Cortex-M implementation. Check device manuals for availability.</dd></dl>
<h1><a class="anchor" id="kernelTimer"></a>
RTX Kernel Timer Tick</h1>
<p>RTX uses the generic <a class="el" href="group__CMSIS__RTOS__TickAPI.html">OS Tick API</a> to configure and control its periodic Kernel Tick.</p>
<p>To use an alternative timer as the Kernel Tick Timer one simply needs to implement a custom version of the <a class="el" href="group__CMSIS__RTOS__TickAPI.html">OS Tick API</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The OS Tick implementation provided must assure that the used timer interrupt uses the same (low) priority group as the service interrupts, i.e. interrupts used by RTX must not preempt each other. Refer to the <a class="el" href="theory_of_operation.html#Scheduler">Scheduler</a> section for more details.</dd></dl>
<h2><a class="anchor" id="TickLess"></a>
Tick-less Low-Power Operation</h2>
<p>RTX5 provides extension for tick-less operation which is useful for applications that use extensively low-power modes where the SysTick timer is also disabled. To provide a time-tick in such power-saving modes, a wake-up timer is used to derive timer intervals. The CMSIS-RTOS2 functions <a class="el" href="group__CMSIS__RTOS__KernelCtrl.html#gae26683e1606ec633354a2876c68f0c1f">osKernelSuspend</a> and <a class="el" href="group__CMSIS__RTOS__KernelCtrl.html#ga8c4b4d7ed34cab73c001665d9176aced">osKernelResume</a> control the tick-less operation.</p>
<p>Using this functions allows the RTX5 thread scheduler to stop the periodic kernel tick interrupt. When all active threads are suspended, the system enters power-down and calculates how long it can stay in this power-down mode. In the power-down mode the processor and peripherals can be switched off. Only a wake-up timer must remain powered, because this timer is responsible to wake-up the system after the power-down period expires.</p>
<p>The tick-less operation is controlled from the <b>osRtxIdleThread</b> thread. The wake-up timeout value is set before the system enters the power-down mode. The function <a class="el" href="group__CMSIS__RTOS__KernelCtrl.html#gae26683e1606ec633354a2876c68f0c1f">osKernelSuspend</a> calculates the wake-up timeout measured in RTX Timer Ticks; this value is used to setup the wake-up timer that runs during the power-down mode of the system.</p>
<p>Once the system resumes operation (either by a wake-up time out or other interrupts) the RTX5 thread scheduler is started with the function <a class="el" href="group__CMSIS__RTOS__KernelCtrl.html#ga8c4b4d7ed34cab73c001665d9176aced">osKernelResume</a>. The parameter <em>sleep_time</em> specifies the time (in RTX Timer Ticks) that the system was in power-down mode.</p>
<p><b>Code Example:</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;msp.h&quot;</span>                        <span class="comment">// Device header</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">/*----------------------------------------------------------------------------</span></div>
<div class="line"><span class="comment"> *      MSP432 Low-Power Extension Functions</span></div>
<div class="line"><span class="comment"> *---------------------------------------------------------------------------*/</span></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> MSP432_LP_Entry(<span class="keywordtype">void</span>) {</div>
<div class="line">  <span class="comment">/* Enable PCM rude mode, which allows to device to enter LPM3 without waiting for peripherals */</span></div>
<div class="line">  PCM-&gt;CTL1 = PCM_CTL1_KEY_VAL | PCM_CTL1_FORCE_LPM_ENTRY;       </div>
<div class="line">  <span class="comment">/* Enable all SRAM bank retentions prior to going to LPM3  */</span></div>
<div class="line">  SYSCTL-&gt;SRAM_BANKRET |= SYSCTL_SRAM_BANKRET_BNK7_RET;</div>
<div class="line">  __enable_interrupt();</div>
<div class="line">  NVIC_EnableIRQ(RTC_C_IRQn);</div>
<div class="line">  <span class="comment">/* Do not wake up on exit from ISR */</span></div>
<div class="line">  SCB-&gt;SCR |= SCB_SCR_SLEEPONEXIT_Msk;</div>
<div class="line">  <span class="comment">/* Setting the sleep deep bit */</span></div>
<div class="line">  SCB-&gt;SCR |= (SCB_SCR_SLEEPDEEP_Msk);  </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tc;</div>
<div class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tc_wakeup;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> RTC_C_IRQHandler(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (tc++ &gt; tc_wakeup) </div>
<div class="line">  {</div>
<div class="line">    SCB-&gt;SCR &amp;= ~SCB_SCR_SLEEPONEXIT_Msk;    </div>
<div class="line">    NVIC_DisableIRQ(RTC_C_IRQn);</div>
<div class="line">    NVIC_ClearPendingIRQ(RTC_C_IRQn);</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordflow">if</span> (RTC_C-&gt;PS0CTL &amp; RTC_C_PS0CTL_RT0PSIFG)</div>
<div class="line">  {</div>
<div class="line">    RTC_C-&gt;CTL0 = RTC_C_KEY_VAL;                 <span class="comment">// Unlock RTC key protected registers</span></div>
<div class="line">    RTC_C-&gt;PS0CTL &amp;= ~RTC_C_PS0CTL_RT0PSIFG;</div>
<div class="line">    RTC_C-&gt;CTL0 = 0;</div>
<div class="line">    SCB-&gt;SCR |= (SCB_SCR_SLEEPDEEP_Msk);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">uint32_t g_enable_sleep = 0;</div>
<div class="line">  </div>
<div class="line"><span class="keywordtype">void</span> osRtxIdleThread (<span class="keywordtype">void</span>) {</div>
<div class="line">  </div>
<div class="line">  <span class="keywordflow">for</span> (;;) {</div>
<div class="line">    tc_wakeup = <a class="code hl_function" href="group__CMSIS__RTOS__KernelCtrl.html#gae26683e1606ec633354a2876c68f0c1f">osKernelSuspend</a>();</div>
<div class="line">    <span class="comment">/* Is there some time to sleep? */</span></div>
<div class="line">    <span class="keywordflow">if</span> (tc_wakeup &gt; 0) {</div>
<div class="line">      tc = 0;</div>
<div class="line">      <span class="comment">/* Enter the low power state */</span></div>
<div class="line">      MSP432_LP_Entry();</div>
<div class="line">      __WFE();</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">/* Adjust the kernel ticks with the amount of ticks slept */</span></div>
<div class="line">    <a class="code hl_function" href="group__CMSIS__RTOS__KernelCtrl.html#ga8c4b4d7ed34cab73c001665d9176aced">osKernelResume</a> (tc);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="agroup__CMSIS__RTOS__KernelCtrl_html_ga8c4b4d7ed34cab73c001665d9176aced"><div class="ttname"><a href="group__CMSIS__RTOS__KernelCtrl.html#ga8c4b4d7ed34cab73c001665d9176aced">osKernelResume</a></div><div class="ttdeci">void osKernelResume(uint32_t sleep_ticks)</div><div class="ttdoc">Resume the RTOS Kernel scheduler.</div></div>
<div class="ttc" id="agroup__CMSIS__RTOS__KernelCtrl_html_gae26683e1606ec633354a2876c68f0c1f"><div class="ttname"><a href="group__CMSIS__RTOS__KernelCtrl.html#gae26683e1606ec633354a2876c68f0c1f">osKernelSuspend</a></div><div class="ttdeci">uint32_t osKernelSuspend(void)</div><div class="ttdoc">Suspend the RTOS Kernel scheduler.</div></div>
</div><!-- fragment --><dl class="section note"><dt>Note</dt><dd><code>__WFE()</code> is not available in every Arm Cortex-M implementation. Check device manuals for availability. The alternative using <code>__WFI()</code> has other issues, please take note of <a href="https://www.keil.com/support/docs/3591.htm">https://www.keil.com/support/docs/3591.htm</a> as well.</dd></dl>
<h1><a class="anchor" id="rtx_os_h"></a>
RTX5 Header File</h1>
<p>Every implementation of the CMSIS-RTOS2 API can bring its own additional features. RTX5 adds a couple of functions for the idle more, for error notifications, and special system timer functions. It also is using macros for control block and memory sizes.</p>
<p>If you require some of the RTX specific functions in your application code, #include the header file <b>rtx_os.h</b>:</p>
<div class="fragment"></div><!-- fragment --><h1><a class="anchor" id="CMSIS_RTOS_TimeOutValue"></a>
Timeout Value</h1>
<p>Timeout values are an argument to several <b>osXxx</b> functions to allow time for resolving a request. A timeout value of <b>0</b> means that the RTOS does not wait and the function returns instantly, even when no resource is available. A timeout value of <a class="el" href="group__CMSIS__RTOS__Definitions.html#ga9eb9a7a797a42e4b55eb171ecc609ddb">osWaitForever</a> means that the RTOS waits infinitely until a resource becomes available. Or one forces the thread to resume using <a class="el" href="group__CMSIS__RTOS__ThreadMgmt.html#ga3dbad90eff394b02de76a452c84c5d80">osThreadResume</a> which is discouraged.</p>
<p>The timeout value specifies the number of timer ticks until the time delay elapses. The value is an upper bound and depends on the actual time elapsed since the last timer tick.</p>
<p>Examples:</p><ul>
<li>timeout value <b>0</b> : the system does not wait, even when no resource is available the RTOS function returns instantly.</li>
<li>timeout value <b>1</b> : the system waits until the next timer tick occurs; depending on the previous timer tick, it may be a very short wait time.</li>
<li>timeout value <b>2</b> : actual wait time is between 1 and 2 timer ticks.</li>
<li>timeout value <a class="el" href="group__CMSIS__RTOS__Definitions.html#ga9eb9a7a797a42e4b55eb171ecc609ddb">osWaitForever</a> : system waits infinite until a resource becomes available.</li>
</ul>
<div class="image">
<img src="TimerValues.png" alt=""/>
<div class="caption">
Example of timeout using osDelay()</div></div>
<h1><a class="anchor" id="CMSIS_RTOS_ISR_Calls"></a>
Calls from Interrupt Service Routines</h1>
<p>The following CMSIS-RTOS2 functions can be called from threads and Interrupt Service Routines (ISR):</p><ul>
<li><a class="el" href="group__CMSIS__RTOS__KernelCtrl.html#ga6f7764e7250c5c5364c00c45a5d1d199">osKernelGetInfo</a>, <a class="el" href="group__CMSIS__RTOS__KernelCtrl.html#ga48b69b81012fce051f639be288b243ba">osKernelGetState</a>, <a class="el" href="group__CMSIS__RTOS__KernelCtrl.html#ga84bcdbf2fb76b10c8df4e439f0c7e11b">osKernelGetTickCount</a>, <a class="el" href="group__CMSIS__RTOS__KernelCtrl.html#ga7a8d7bd927eaaa58999f91d7d6310cee">osKernelGetTickFreq</a>, <a class="el" href="group__CMSIS__RTOS__KernelCtrl.html#gae0fcaff6cecfb4013bb556c87afcd7d2">osKernelGetSysTimerCount</a>, <a class="el" href="group__CMSIS__RTOS__KernelCtrl.html#ga4d69215a93220f72be3684cad582f16a">osKernelGetSysTimerFreq</a></li>
<li><a class="el" href="group__CMSIS__RTOS__ThreadMgmt.html#gac3230f3a55a297514b013ebf38f27e0a">osThreadGetName</a>, <a class="el" href="group__CMSIS__RTOS__ThreadMgmt.html#ga8df03548e89fbc56402a5cd584a505da">osThreadGetId</a>, <a class="el" href="group__CMSIS__RTOS__ThreadFlagsMgmt.html#ga6f89ef9caded1d9963c7b12b0f6412c9">osThreadFlagsSet</a></li>
<li><a class="el" href="group__CMSIS__RTOS__TimerMgmt.html#ga4f82a98eee4d9ea79507e44340d3d319">osTimerGetName</a></li>
<li><a class="el" href="group__CMSIS__RTOS__EventFlags.html#ga59f4ddf0ee8c395b1672bb978d1cfc88">osEventFlagsGetName</a>, <a class="el" href="group__CMSIS__RTOS__EventFlags.html#ga33b71d14cecf90b4e72639dd19f23a5e">osEventFlagsSet</a>, <a class="el" href="group__CMSIS__RTOS__EventFlags.html#ga93bf258ca0007c6641fbe8e4f2b8a1e5">osEventFlagsClear</a>, <a class="el" href="group__CMSIS__RTOS__EventFlags.html#ga8bda3185f46bfd278cea8a6cf357677d">osEventFlagsGet</a>, <a class="el" href="group__CMSIS__RTOS__EventFlags.html#ga52acb34a8322e58020227344fe662b4e">osEventFlagsWait</a></li>
<li><a class="el" href="group__CMSIS__RTOS__MutexMgmt.html#ga00b5e58cd247a412d1afd18732d8b752">osMutexGetName</a></li>
<li><a class="el" href="group__CMSIS__RTOS__SemaphoreMgmt.html#ga9586952051f00285f1482dbe6695bbc4">osSemaphoreGetName</a>, <a class="el" href="group__CMSIS__RTOS__SemaphoreMgmt.html#ga7e94c8b242a0c81f2cc79ec22895c87b">osSemaphoreAcquire</a>, <a class="el" href="group__CMSIS__RTOS__SemaphoreMgmt.html#ga0abcee1b5449d7a6928fb9248c690bb6">osSemaphoreRelease</a>, <a class="el" href="group__CMSIS__RTOS__SemaphoreMgmt.html#ga7559d4dff3cda9992fc5ab5de3e74c70">osSemaphoreGetCount</a></li>
<li><a class="el" href="group__CMSIS__RTOS__PoolMgmt.html#gab414a1e138205a55820acfa277c8f386">osMemoryPoolGetName</a>, <a class="el" href="group__CMSIS__RTOS__PoolMgmt.html#ga8ead54e99ccb8f112356c88f99d38fbe">osMemoryPoolAlloc</a>, <a class="el" href="group__CMSIS__RTOS__PoolMgmt.html#gabb4f4560daa6d1f8c8789082ee186d16">osMemoryPoolFree</a>, <a class="el" href="group__CMSIS__RTOS__PoolMgmt.html#gad696e94bfbe28f0b6613f9303fdf6a37">osMemoryPoolGetCapacity</a>, <a class="el" href="group__CMSIS__RTOS__PoolMgmt.html#gab2bf059b7fa7679c3cccdaeec60b6c0e">osMemoryPoolGetBlockSize</a>, <a class="el" href="group__CMSIS__RTOS__PoolMgmt.html#ga958a9449bff8c95ce213de98eef5739d">osMemoryPoolGetCount</a>, <a class="el" href="group__CMSIS__RTOS__PoolMgmt.html#ga0394cffa9479a7994e3b03c79c1cb909">osMemoryPoolGetSpace</a></li>
<li><a class="el" href="group__CMSIS__RTOS__Message.html#gae7cf7bf2b97a5ae481fb60fcce99247a">osMessageQueueGetName</a>, <a class="el" href="group__CMSIS__RTOS__Message.html#gaa515fc8b956f721a8f72b2c505813bfc">osMessageQueuePut</a>, <a class="el" href="group__CMSIS__RTOS__Message.html#gad90d4959466a7a65105061da8256ab9e">osMessageQueueGet</a>, <a class="el" href="group__CMSIS__RTOS__Message.html#gac24f87d4f395e9e9c900c320e45ade8a">osMessageQueueGetCapacity</a>, <a class="el" href="group__CMSIS__RTOS__Message.html#ga96d3d84069b20359de48109e28a1a89e">osMessageQueueGetMsgSize</a>, <a class="el" href="group__CMSIS__RTOS__Message.html#ga6a32ac394fcff568b251c160cc3014b2">osMessageQueueGetCount</a>, <a class="el" href="group__CMSIS__RTOS__Message.html#gaddf0904427436dd3880d46263c2dc9fa">osMessageQueueGetSpace</a></li>
</ul>
<p>Functions that cannot be called from an ISR are verifying the interrupt status and return the status code <b>osErrorISR</b>, in case they are called from an ISR context. In some implementations, this condition might be caught using the HARD_FAULT vector.</p>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>RTX does not disable interrupts during critical sections for Armv7-M and Armv8-M architecture based devices, but rather uses atomic operations.</li>
<li>Therefore, there is no need to configure interrupt priorities of interrupt service routines that use RTOS functions.</li>
</ul>
</dd></dl>
<h1><a class="anchor" id="CMSIS_RTOS_svcFunctions"></a>
SVC Functions</h1>
<p>Supervisor Calls (SVC) are exceptions targeted at software and operating systems for generating system function calls. They are sometimes called software interrupts. For example, instead of allowing user programs to directly access hardware, an operating system may provide access to hardware through an SVC. So when a user program wants to use certain hardware, it generates the exception using SVC instructions. The software exception handler in the operating system executes and provides the requested service to the user application. In this way, access to hardware is under the control of the OS, which can provide a more robust system by preventing the user applications from directly accessing the hardware.</p>
<p>SVCs can also make software more portable because the user application does not need to know the programming details of the underlying hardware. The user program will only need to know the application programming interface (API) function ID and parameters; the actual hardware-level programming is handled by device drivers.</p>
<p>SVCs run in <b>privileged</b> <b>handler</b> mode of the Arm Cortex-M core. SVC functions accept arguments and can return values. The functions are used in the same way as other functions; however, they are executed indirectly through the SVC instruction. When executing SVC instructions, the controller changes to the privileged handler mode.</p>
<p>Interrupts are <b>not</b> <b>disabled</b> in this mode. To protect SVC functions from interrupts, you need to include the disable/enable intrinsic functions <code>__disable_irq()</code> and <code>__enable_irq()</code> in your code.</p>
<p>You can use SVC functions to access <b>protected</b> <b>peripherals</b>, for example, to configure NVIC and interrupts. This is required if you run threads in unprivileged (protected) mode and you need to change interrupts from the within the thread.</p>
<p>To implement SVC functions in your Keil RTX5 project, you need to:</p><ol type="1">
<li>Add the SVC User Table file <b>svc_user.c</b> to your project folder and include it into your project. This file is available as a user code template.</li>
<li>Write a function implementation. Example: <div class="fragment"><div class="line">uint32_t svc_atomic_inc32 (uint32_t *mem) {</div>
<div class="line">  <span class="comment">// A protected function to increment a counter. </span></div>
<div class="line">  uint32_t val;</div>
<div class="line">   </div>
<div class="line">  __disable_irq();</div>
<div class="line">  val  = *mem;</div>
<div class="line">  (*mem) = val + 1U;</div>
<div class="line">  __enable_irq();</div>
<div class="line">   </div>
<div class="line">  <span class="keywordflow">return</span> (val);</div>
<div class="line">}</div>
</div><!-- fragment --></li>
<li>Add the function to the SVC function table in the <b>svc_user.c</b> module: <div class="fragment"><div class="line"><span class="keywordtype">void</span> * <span class="keyword">const</span> osRtxUserSVC[1+USER_SVC_COUNT] = {</div>
<div class="line">  (<span class="keywordtype">void</span> *)USER_SVC_COUNT,</div>
<div class="line">  (<span class="keywordtype">void</span> *)svc_atomic_inc32,</div>
<div class="line">};</div>
</div><!-- fragment --></li>
<li>Increment the number of user SVC functions: <div class="fragment"><div class="line"><span class="preprocessor">#define USER_SVC_COUNT  1       </span><span class="comment">// Number of user SVC functions</span></div>
</div><!-- fragment --></li>
<li><p class="startli">Declare a function wrapper to be called by the user to execute the SVC call.<br  />
 <b>Code</b> <b>Example</b> (Arm Compiler 6) </p><div class="fragment"><div class="line">__STATIC_FORCEINLINE uint32_t atomic_inc32 (uint32_t *mem) {</div>
<div class="line">  <span class="keyword">register</span> uint32_t val;</div>
<div class="line"> </div>
<div class="line">  __ASM <span class="keyword">volatile</span> (</div>
<div class="line">    <span class="stringliteral">&quot;svc 1&quot;</span> : <span class="stringliteral">&quot;=l&quot;</span> (val) : <span class="stringliteral">&quot;l&quot;</span> (mem) : <span class="stringliteral">&quot;cc&quot;</span>, <span class="stringliteral">&quot;memory&quot;</span></div>
<div class="line">  );</div>
<div class="line">  <span class="keywordflow">return</span> (val);</div>
<div class="line">}</div>
</div><!-- fragment --><p class="startli"><b>Code</b> <b>Example</b> (Arm Compiler 5 using <code>__svc(x)</code> attribute) </p><div class="fragment"><div class="line">uint32_t atomic_inc32 (uint32_t *mem) __svc(1);</div>
</div><!-- fragment --></li>
</ol>
<dl class="section note"><dt>Note</dt><dd><ul>
<li>The SVC function <span class="XML-Token">0</span> is <b>reserved</b> for the Keil RTX5 kernel.</li>
<li>Do not leave gaps when numbering SVC functions. They must occupy a <b>continuous</b> range of numbers starting from 1.</li>
<li>SVC functions can still be interrupted.</li>
</ul>
</dd></dl>
<h1><a class="anchor" id="cre_rtx_proj_clib_arm"></a>
Arm C library multi-threading protection</h1>
<p>RTX5 provides an interface to the <a href="https://developer.arm.com/docs/dui0475/m/the-arm-c-and-c-libraries/multithreaded-support-in-arm-c-libraries" target="_blank"><b>Arm C libraries</b></a> to ensure static data protection in a multi-threaded application.</p>
<p>The Arm C libraries use static data to store errno, floating-point status word for software floating-point operations, a pointer to the base of the heap, and other variables. The Arm C micro-library (i.e. microlib) does not support protection for multi-threaded applications. See the <a href="https://developer.arm.com/docs/dui0475/m/the-arm-c-micro-library/differences-between-microlib-and-the-default-c-library" target="_blank"><b>limitations and differences</b></a> between microlib and the default C library.</p>
<p>By default, RTX5 uses the Arm C libraries multi-thread protection for:</p><ul>
<li>all user threads if <a class="el" href="config_rtx5.html#threadConfig">Object specific Memory allocation</a> is enabled.</li>
<li>the number of threads defined by <b>OS_THREAD_LIBSPACE_NUM</b> if <a class="el" href="config_rtx5.html#threadConfig">Object specific Memory allocation</a> is disabled. The definition <b>OS_THREAD_LIBSPACE_NUM</b> defines the number of threads that can safely call Arm C library functions and can be found in "RTX_Config.h" file or can be defined on the global scope.</li>
</ul>
<p>The default, Arm C libraries use mutex functions to <a href="https://developer.arm.com/docs/dui0475/m/the-arm-c-and-c-libraries/multithreaded-support-in-arm-c-libraries/management-of-locks-in-multithreaded-applications" target="_blank"><b>protect shared resources from concurrent access</b></a>. RTX5 implements these functions and uses resources from the <a class="el" href="config_rtx5.html#systemConfig">Global Dynamic Memory</a> to allocate mutex objects.  </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">
      <script type="text/javascript">
        <!--
        writeFooter.call(this);
        //-->
      </script> 
    </li>
  </ul>
</div>
</body>
</html>
